//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "KeyboardActivity.hh"
#include "ComponentKeyboardJoystick.hh"

#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>

#include <thread>
#include <iostream>

KeyboardActivity::KeyboardActivity(SmartACE::SmartComponent *comp) 
:	KeyboardActivityCore(comp)
{
	std::cout << "constructor KeyboardActivity\n";

	xAcceleration = 0.1;
	maxX = 1.0;
	yAcceleration = 0.1;
	maxY = 1.0;

	xPos = 0.0;
	yPos = 0.0;

	// set to false to deactivate cout
	verbose = true;
}
KeyboardActivity::~KeyboardActivity() 
{
	std::cout << "destructor KeyboardActivity\n";
}

// Implementation on kbhit taken from :
// http://cboard.cprogramming.com/c-programming/63166-kbhit-linux.html
int kbhit(void)
{
  struct termios oldt, newt;
  int ch;
  int oldf;

  tcgetattr(STDIN_FILENO, &oldt);
  newt = oldt;
  newt.c_lflag &= ~(ICANON | ECHO);
  tcsetattr(STDIN_FILENO, TCSANOW, &newt);
  oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
  fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

  ch = getchar();

  tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
  fcntl(STDIN_FILENO, F_SETFL, oldf);

  if(ch != EOF)
  {
    ungetc(ch, stdin);
    return 1;
  }

  return 0;
}

int KeyboardActivity::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int KeyboardActivity::on_execute()
{
	if(kbhit()) {
			char c = getchar();

			bool accelerating = false;
			bool breaking = false;
			bool left = false;
			bool right = false;

			/*Arrow keys*/
			if (c == '\033') { // if the first value is esc
			    getchar(); // skip the [
			    switch(getchar()) { // the real value
			        case 'A':
			        	xPos += xAcceleration;
			            break;
			        case 'B':
			        	xPos -= xAcceleration;
			            break;
			        case 'C':
			        	yPos -= yAcceleration;
			            break;
			        case 'D':
			        	yPos += yAcceleration;
			            break;
			    }
			 /*WASD*/
			}else if(c == 'w') {
				accelerating = true;
				breaking = false;
			} else if (c == 'd') {
				left = false;
				right = true;
			} else if (c == 'a') {
				left = true;
				right = false;
			} else if (c == 's') {
				accelerating = false;
				breaking = true;
			} else if (c == 'q') {
				std::cout << "Emergency fullstop" << std::endl;
				xPos = 0;
				yPos = 0;
			}

			if(accelerating == true) {
				if(xPos >= maxX) {
					xPos = maxX;
				} else {
					xPos += xAcceleration;
				}
			} else if(breaking == true) {
				if(xPos <= -1 * maxX) {
					xPos = -1 * maxX;
				} else {
					xPos -= xAcceleration;
				}
			} else {
				if(xPos < -1 * xAcceleration) {
					// reducing breaking gradually
					xPos += xAcceleration;
				} else if(xPos > xAcceleration) {
					// decelerating gradually
					xPos -= xAcceleration;
				} else {
					xPos = 0.0;
				}
			}

			if(left == true) {
				if(yPos >= maxY) {
					yPos = maxY;
				} else {
					yPos += yAcceleration;
				}
			} else if(right == true) {
				if(yPos <= -1 * maxY) {
					yPos = -1 * maxY;
				} else {
					yPos -= yAcceleration;
				}
			} else {
				if(yPos < -1 * yAcceleration) {
					yPos += yAcceleration;
				} else if(yPos > yAcceleration) {
					yPos -= yAcceleration;
				} else {
					yPos = 0;
				}
			}

			if(verbose == true) std::cout << "\nxPos: " << xPos << "; yPos: " << yPos << std::endl;
		} else {
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			if(xPos < -1*xAcceleration) {
				// reducing breaking gradually
				xPos += xAcceleration;
			} else if(xPos > xAcceleration) {
				// decelerating gradually
				xPos -= xAcceleration;
			} else {
				xPos = 0.0;
			}
			if(yPos < -1 * yAcceleration) {
				yPos += yAcceleration;
			} else if(yPos > yAcceleration) {
				yPos -= yAcceleration;
			} else {
				yPos = 0;
			}
			if(verbose == true) std::cout << "no button pressed, xPos: " << xPos << "; yPos: " << yPos << std::endl;
		}

		CommBasicObjects::CommJoystick comm_joy;
		comm_joy.set_x(xPos);
		comm_joy.set_y(yPos);
		std::cout << "push: " << comm_joy << std::endl;
		this->joystickServiceOutPut(comm_joy);

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int KeyboardActivity::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
