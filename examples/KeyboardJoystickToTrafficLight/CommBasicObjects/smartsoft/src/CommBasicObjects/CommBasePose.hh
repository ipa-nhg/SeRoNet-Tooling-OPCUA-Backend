//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2003 Boris Kluge
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Basic Communication Classes".
//  It provides basic standardized data types for communication between
//  different components in the mobile robotics context. These classes
//  are designed to be used in conjunction with the SmartSoft Communication
//  Library.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  (partly based on work by Christian Schlegel and Pablo d'Angelo)
//
// --------------------------------------------------------------------------


#ifndef COMMBASICOBJECTS_COMMBASEPOSE_H_
#define COMMBASICOBJECTS_COMMBASEPOSE_H_

#include "CommBasicObjects/CommBasePoseCore.hh"
#include "CommBasicObjects/CommDirection3d.hh"

namespace CommBasicObjects {

/**
  Description of the position of a mobile robot.
  The Description of the mobile robot position includes
  <ul>
    <li>a three dimensional position,
    <li>the orientation in the plane (azimuth) of
      <ul>
        <li>the base,
        <li>the steering direction, and
        <li>the turret direction,
      </ul>
    <li>the covariance matrix for the (x,y) position and the base orientation, and
    <li>indicates if the covariance is invalid
    <li>an update counter which is increased whenever the base server changes its
        coordinate system (due to self localization).
  </ul>
 */
class CommBasePose : public CommBasePoseCore {
	public:
		// default constructors
		CommBasePose();
		
		/**
		 * Constructor to set all values.
		 * NOTE that you have to keep this constructor consistent with the model!
		 * Use  at your own choice.
		 *
		 * The preferred way to set values for initialization is:
		 *      CommRepository::MyCommObject obj;
		 *      obj.setX(1).setY(2).setZ(3)...;
		 */
		// CommBasePose(const bool &covInvalid, const CommBasicObjects::CommPose3d &pose3D, const CommBasicObjects::CommTimeStamp &timeStamp, const std::vector<double> &covMatrix = std::vector<double>(9, 0.0), const unsigned int &updateCount = 0);
		
		CommBasePose(const CommBasePoseCore &commBasePose);
		CommBasePose(const DATATYPE &commBasePose);
		virtual ~CommBasePose();
		
		// use framework specific getter and setter methods from core (base) class
		using CommBasePoseCore::get;
		using CommBasePoseCore::set;
		
		//
		// feel free to add customized methods here
		//
		/**
		 Get the x position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline double get_x(const double unit = 0.001) const {
			return idl_CommBasePose.pose3D.position.x * (0.001 / unit);
		}

		/**
		 Get the y position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline double get_y(const double unit = 0.001) const {
			return idl_CommBasePose.pose3D.position.y * (0.001 / unit);
		}

		/**
		 Get the z position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline double get_z(const double unit = 0.001) const {
			return idl_CommBasePose.pose3D.position.z * (0.001 / unit);
		}

		/**
		 Return the orientation of the base
		 in the global coordinate system.
		 */
		inline double get_base_azimuth() const {
			return idl_CommBasePose.pose3D.orientation.azimuth;
		}
		inline double get_base_elevation() const {
			return idl_CommBasePose.pose3D.orientation.elevation;
		}
		inline double get_base_roll() const {
			return idl_CommBasePose.pose3D.orientation.roll;
		}

		/**
		 Return the update count of this base position instance.
		 The base server increases the update count whenever it changes its coordinate system.
		 */
		inline unsigned long get_update_count() const {
			return idl_CommBasePose.updateCount;
		}

		/**
		 Return the condition of the covariance matrix.
		 */
		inline bool get_cov_invalid() const {
			return idl_CommBasePose.covInvalid;
		}

		/**
		 Return an element of the position covariance matrix.
		 Index counting starts at zero.
		 */
		inline double get_cov(unsigned int i, unsigned int j) const;

		//
		// CONVERSION METHODS
		//

		inline CommPosition3d get_position3d() const {
			//return CommPosition3d(idl_CommBasePose.x, idl_CommBasePose.y, idl_CommBasePose.z);
			return CommPosition3d(idl_CommBasePose.pose3D.position);
		}
		inline CommDirection3d get_base_direction3d() const {
			return CommDirection3d().setAzimuth(idl_CommBasePose.pose3D.orientation.azimuth).setElevation(idl_CommBasePose.pose3D.orientation.elevation);
		}

		inline CommOrientation3d get_base_orientation3d() const {
	//		return CommOrientation3d(idl_CommBasePose.a_base, 0, 0);
			return getPose3D().getOrientation();
		}
		inline CommPose3d get_base_pose3d() const {
	//		return CommPose3d(get_position3d(), get_base_orientation3d());
			return getPose3D();
		}

		//
		// COORDINATE SYSTEM CONVERSION METHODS
		//
		/*
		 inline CommPosition3d convert_base2world(const CommPosition3d &pos) const;
		 inline CommPosition3d convert_turret2world(const CommPosition3d &pos) const;
		 inline CommPosition3d convert_steer2world(const CommPosition3d &pos) const;

		 inline CommDirection3d convert_base2world(const CommDirection3d &pos) const;
		 inline CommDirection3d convert_turret2world(const CommDirection3d &pos) const;
		 inline CommDirection3d convert_steer2world(const CommDirection3d &pos) const;

		 inline CommOrientation3d convert_base2world(const CommOrientation3d &pos) const;
		 inline CommOrientation3d convert_turret2world(const CommOrientation3d &pos) const;
		 inline CommOrientation3d convert_steer2world(const CommOrientation3d &pos) const;

		 inline CommPose3d convert_base2world(const CommPose3d &pos) const;
		 inline CommPose3d convert_turret2world(const CommPose3d &pos) const;
		 inline CommPose3d convert_steer2world(const CommPose3d &pos) const;


		 inline CommPosition3d convert_world2base(const CommPosition3d &pos) const;
		 inline CommPosition3d convert_world2turret(const CommPosition3d &pos) const;
		 inline CommPosition3d convert_world2steer(const CommPosition3d &pos) const;

		 inline CommDirection3d convert_world2base(const CommDirection3d &pos) const;
		 inline CommDirection3d convert_world2turret(const CommDirection3d &pos) const;
		 inline CommDirection3d convert_world2steer(const CommDirection3d &pos) const;

		 inline CommOrientation3d convert_world2base(const CommOrientation3d &pos) const;
		 inline CommOrientation3d convert_world2turret(const CommOrientation3d &pos) const;
		 inline CommOrientation3d convert_world2steer(const CommOrientation3d &pos) const;

		 inline CommPose3d convert_world2base(const CommPose3d &pos) const;
		 inline CommPose3d convert_world2turret(const CommPose3d &pos) const;
		 inline CommPose3d convert_world2steer(const CommPose3d &pos) const;
		 */
		//
		// SET
		//

		/**
		 Set the x position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline void set_x(double x, const double unit = 0.001) {
			idl_CommBasePose.pose3D.position.x = x * (unit * 1000);
		}

		/**
		 Set the y position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline void set_y(double y, const double unit = 0.001) {
			idl_CommBasePose.pose3D.position.y = y * (unit * 1000);
		}

		/**
		 Set the z position in units of \a unit meters.
		 Default unit is millimeters.
		 */
		inline void set_z(double z, const double unit = 0.001) {
			idl_CommBasePose.pose3D.position.z = z * (unit * 1000);
		}

		/**
		 Set the base orientation in radians.
		 Either the baseserver sets this value to report the current orientation of
		 the base, or the client sets this value in order to redefine the base orientation
		 (for self-localisation).
		 */
		inline void set_base_azimuth(double azimuth) {
			idl_CommBasePose.pose3D.orientation.azimuth = azimuth;
		}

		inline void set_base_elevation(double elevation) {
			idl_CommBasePose.pose3D.orientation.elevation = elevation;
		}

		inline void set_base_roll(double roll) {
			idl_CommBasePose.pose3D.orientation.roll = roll;
		}

		/**
		 Set the update counter of this base position instance.
		 The baseserver increases the update counter whenever it changes its coordinate system.
		 */
		inline void set_update_count(unsigned long l) {
			idl_CommBasePose.updateCount = l;
		}

		/**
		 Set an element of the covariance matrix of the position.
		 Index counting starts at zero.
		 */
		inline void set_cov(unsigned int i, unsigned int j, double d);

		/**
		 Set the condition of the covariance matrix.
		 */
		inline void set_cov_invalid(bool b) {
			idl_CommBasePose.covInvalid = b;
		}
};

//
// Implementation
//

inline double CommBasePose::get_cov(unsigned int i, unsigned int j) const
{
  return getCovMatrixElemAtPos(i*3+j); //dst
  // FIXME: check this
  //return idl_CommBasePose.covMatrix[i*3+j];
}

inline void CommBasePose::set_cov(unsigned int i, unsigned int j, double d)
{
	setCovMatrixElemAtPos(i*3+j, d); //dst
	// FIXME: check this
	//idl_CommBasePose.covMatrix[i*3+j] = d;
}

/*
inline CommPosition3d CommBasePosition::convert_base2world(const CommPosition3d &pos) const
{
}


inline CommPosition3d CommBasePosition::convert_turret2world(const CommPosition3d &pos) const
{
}


inline CommPosition3d CommBasePosition::convert_steer2world(const CommPosition3d &pos) const
{
}



inline CommDirection3d CommBasePosition::convert_base2world(const CommDirection3d &pos) const
{
}


inline CommDirection3d CommBasePosition::convert_turret2world(const CommDirection3d &pos) const
{
}


inline CommDirection3d CommBasePosition::convert_steer2world(const CommDirection3d &pos) const
{
}



inline CommOrientation3d CommBasePosition::convert_base2world(const CommOrientation3d &pos) const
{
}


inline CommOrientation3d CommBasePosition::convert_turret2world(const CommOrientation3d &pos) const
{
}


inline CommOrientation3d CommBasePosition::convert_steer2world(const CommOrientation3d &pos) const
{
}



inline CommPose3d CommBasePosition::convert_base2world(const CommPose3d &pos) const
{
}


inline CommPose3d CommBasePosition::convert_turret2world(const CommPose3d &pos) const
{
}


inline CommPose3d CommBasePosition::convert_steer2world(const CommPose3d &pos) const
{
}




inline CommPosition3d CommBasePosition::convert_world2base(const CommPosition3d &pos) const
{
}


inline CommPosition3d CommBasePosition::convert_world2turret(const CommPosition3d &pos) const
{
}


inline CommPosition3d CommBasePosition::convert_world2steer(const CommPosition3d &pos) const
{
}



inline CommDirection3d CommBasePosition::convert_world2base(const CommDirection3d &pos) const
{
}


inline CommDirection3d CommBasePosition::convert_world2turret(const CommDirection3d &pos) const
{
}


inline CommDirection3d CommBasePosition::convert_world2steer(const CommDirection3d &pos) const
{
}



inline CommOrientation3d CommBasePosition::convert_world2base(const CommOrientation3d &pos) const
{
}


inline CommOrientation3d CommBasePosition::convert_world2turret(const CommOrientation3d &pos) const
{
}


inline CommOrientation3d CommBasePosition::convert_world2steer(const CommOrientation3d &pos) const
{
}



inline CommPose3d CommBasePosition::convert_world2base(const CommPose3d &pos) const
{
}


inline CommPose3d CommBasePosition::convert_world2turret(const CommPose3d &pos) const
{
}


inline CommPose3d CommBasePosition::convert_world2steer(const CommPose3d &pos) const
{
}

*/

inline std::ostream &operator<<(std::ostream &os, const CommBasePose &co)
{
	co.to_ostream(os);
	return os;
}
	
} /* namespace CommBasicObjects */
#endif /* COMMBASICOBJECTS_COMMBASEPOSE_H_ */
