//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------


// --------------------------------------------------------------------------
//
//  Copyright (C) 2003 Boris Kluge
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Basic Communication Classes".
//  It provides basic standardized data types for communication between
//  different components in the mobile robotics context. These classes
//  are designed to be used in conjunction with the SmartSoft Communication
//  Library.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  (partly based on work by Christian Schlegel and Pablo d'Angelo)
//
// --------------------------------------------------------------------------

#ifndef COMMBASICOBJECTS_COMMTIMESTAMP_H_
#define COMMBASICOBJECTS_COMMTIMESTAMP_H_

#include "CommBasicObjects/CommTimeStampCore.hh"

namespace CommBasicObjects {
		
class CommTimeStamp : public CommTimeStampCore {
	public:
		// default constructors
		CommTimeStamp();
		
		/**
		 * Constructor to set all values.
		 * NOTE that you have to keep this constructor consistent with the model!
		 * Use  at your own choice.
		 *
		 * The preferred way to set values for initialization is:
		 *      CommRepository::MyCommObject obj;
		 *      obj.setX(1).setY(2).setZ(3)...;
		 */
		// CommTimeStamp(const unsigned int &sec = 0, const unsigned int &usec = 0);
		
		CommTimeStamp(const CommTimeStampCore &commTimeStamp);
		CommTimeStamp(const DATATYPE &commTimeStamp);
		virtual ~CommTimeStamp();
		
		// use framework specific getter and setter methods from core (base) class
		using CommTimeStampCore::get;
		using CommTimeStampCore::set;
		
		//
		// feel free to add customized methods here
		//
		inline CommTimeStamp(const timeval &tv) {
			set(tv);
		}

		/**
		 Convert this timestamp into a \c timeval.
		 */
		inline timeval get() const;

		/**
		 Copy this timestamp to the given \c timeval \a t reference argument.
		 */
		inline void get(timeval &t) const;

		/**
		 Get the seconds of this timestamp.
		 */
		inline unsigned long get_seconds() const {
			return idl_CommTimeStamp.sec;
		}

		/**
		 Get the microseconds of this timestamp.
		 */
		inline unsigned long get_microseconds() const {
			return idl_CommTimeStamp.usec;
		}

		/**
		 Set this timestamp.
		 */
		inline void set(const timeval &t);

		/**
		 Set this timestamp to the given seconds and microseconds.
		 */
		inline void set(unsigned long seconds, unsigned long microseconds) {
			idl_CommTimeStamp.sec = seconds + microseconds / 1000000;
			idl_CommTimeStamp.usec = microseconds % 1000000;
		}

		/**
		 Return a string representation of the timestamp.
		 The format of the string complies with the format of the \c dateTime type in XML Schema.
		 */
		std::string get_string() const;

		/**
		 Set this timestamp to the current time.
		 */
		void set_now();

		/**
		 Create a timestamp representing the current time.
		 */
		static CommTimeStamp now();

		/**
		 Advance this time stamp by the given amount in seconds.
		 The amount may be negative.
		 \return this time stamp after having been advances.
		 */
		CommTimeStamp &advance(double dt);

		/**
		 Decide if this timestamp is before the \a other timestamp.
		 */
		inline bool is_before(const CommTimeStamp &other) const;

		/**
		 Decide if this and the \a other timestamp are coincident.
		 */
		inline bool is_equal(const CommTimeStamp &other) const;

		/**
		 Decide if this timestamp is after the \a other timestamp.
		 */
		inline bool is_after(const CommTimeStamp &other) const {
			return other.is_before(*this);
		}

		/**
		 Return the signed interval between this timestamp and the \a other timestamp in seconds.
		 A negative value is returned if the \a other timestamp lies before this timestamp.
		 */
		inline double seconds_before(const CommTimeStamp &other) const;

		/**
		 Return the signed interval between the \a other timestamp and this timestamp in seconds.
		 A negative value is returned if this timestamp lies before the \a other timestamp.
		 */
		inline double seconds_after(const CommTimeStamp &other) const {
			return other.seconds_before(*this);
		}
};

//
// Implementation
//


inline timeval CommTimeStamp::get() const
{
  timeval t;
  this->get(t);
  return t;
}

inline void CommTimeStamp::get(timeval &t) const
{
  t.tv_sec  = idl_CommTimeStamp.sec;
  t.tv_usec = idl_CommTimeStamp.usec;
}

inline void CommTimeStamp::set(const timeval &t)
{
  idl_CommTimeStamp.sec  = t.tv_sec;
  idl_CommTimeStamp.usec = t.tv_usec;
}

inline bool CommTimeStamp::is_before(const CommTimeStamp &other) const
{
  return (idl_CommTimeStamp.sec < other.idl_CommTimeStamp.sec) || ((idl_CommTimeStamp.sec == other.idl_CommTimeStamp.sec) && (idl_CommTimeStamp.usec < other.idl_CommTimeStamp.usec));
}

inline bool CommTimeStamp::is_equal(const CommTimeStamp &other) const
{
  return (idl_CommTimeStamp.sec == other.idl_CommTimeStamp.sec) && (idl_CommTimeStamp.usec == other.idl_CommTimeStamp.usec);
}

inline double CommTimeStamp::seconds_before(const CommTimeStamp &other) const
{
  return (other.idl_CommTimeStamp.sec - double(idl_CommTimeStamp.sec)) // convert to double before subtract as we're using unsigned integers
       + 1e-6 * (other.idl_CommTimeStamp.usec - double(idl_CommTimeStamp.usec)); // same here
}

inline std::ostream &operator<<(std::ostream &os, const CommTimeStamp &co)
{
	co.to_ostream(os);
	return os;
}
	
} /* namespace CommBasicObjects */
#endif /* COMMBASICOBJECTS_COMMTIMESTAMP_H_ */
